****************************************************
``libvirt_vmcfg.dom.elements``: Elements for domains
****************************************************
.. py:module:: libvirt_vmcfg.dom.elements

This module contains the basic framework for producing subclasses of elements.

########
Synopsis
########
Elements are subclasses of :py:class:`Element` which act as the building blocks
for the final XML sheet generated by the
:py:class:`~libvirt_vmcfg.dom.domain.Domain` class.

Each element class takes in state (if needed) that will later be used by the
:py:meth:`Element.attach_xml` method. This method performs the actual XML
generation and attachment to the tree.

Note that the elements themselves have no knowledge of the domain instance â€”
they are not coupled to the :py:class:`~libvirt_vmcfg.dom.domain.Domain`. This
prevents tight coupling.

The upshot of this is that the elements are reusable, that is, a new instance
is not required for each new :py:class:`~libvirt_vmcfg.dom.domain.Domain`, and
allows you to build your own applications on top of the elements if so desired.
All the state is kept outside the elements.

###
API
###
Below is the documentation for the actual elements API

========
Base API
========

-------
Element
-------
.. py:class:: Element

   :synopsis: The base element class. This class is partially abstract.

   .. py:attribute:: unique
      :type: bool
      :value: False

      Determines whether only one element of this **exact** type should be
      allowed. Subclasses of this element will not count as unique, only the
      exact type of the class.

      .. warning:: It is best to set this explicitly ``True`` or ``False``, and
                   not rely on inherited behaviour.

   .. py:method:: bool_to_str(val: bool) -> str
      :staticmethod:

      :param bool val: Value to convert to a string.
      :return: A string containing ``"yes"`` if ``val`` is ``True``, otherwise
               ``"no"``.

      Internal method for use by subclasses to convert a boolean value into a
      ``"yes"`` or ``"no"`` string, as used ubiquitiously by libvirt.

   .. py:method:: node_find_or_create(_root: etree._Element, _name: str, \
                                      **kwargs: Any) -> lxml.etree._Element

      :param lxml.etree._Element _root: root node to search or attach element
                                        to.
      :param str _name: name of the node to search for, or create if not found.
      :param \**kwargs: passed to :py:func:`~lxml.etree.SubElement` if the
                        node is not found.

      Internal method for finding or creating a given element. This is usually
      used for finding a node to attach other elements onto, such as the
      ``<devices>`` tag.

      The parameters are prefixed with underscores to prevent conflict with any
      keyword arguments passed on to :py:func:`~lxml.etree.SubElement`.

   .. py:method:: attach_xml(root: lxml.etree._Element) -> \
                             Sequence[lxml.etree._Element]
      :abstractmethod:

      :param lxml.etree._Element root: root node to attach elements to.
      :return: A :py:class:`~python.typing.Sequence` that is either empty or
               contains :py:class:`lxml.etree._Element` instances. These are
               the elements attached to the tree whose root is referenced by
               the ``root`` parameter.

      Attach XML node or nodes to the given root node referenced by ``root``.
      The nodes unique to this given element should be returned in this list,
      for later cleanup if :py:meth:`~libvirt_vmcfg.dom.Domain.detach_element`
      is called.

   .. py:method:: detach_xml(tags: Sequence[lxml.etree._Element]) -> None

      :param Sequence[lxml.etree._Element] tags: Tags to remove.

      Detaches the given XML nodes from the root of the tree deduced from the
      tags themselves. For simple elements, you usually do not need to override
      this method, as the behaviour does the right thing for you.

This submodule contains elements (inheriting from
:py:class:`~libvirt_vmcfg.dom.elements.Element`) that can be used to specify
all the elements a libvirt domain XML specification requires.

===================
Non-device elements
===================
The following elements are all required to be unique. See the documentation on
the :py:attr:`Element.unique` attribute for more information.

.. note:: As these follow the same API as the :py:class:`Element` class, the
          API will not be redocumented.

-----------
Description
-----------
.. py:module:: libvirt_vmcfg.dom.elements.description

Element providing description of the domain.

.. py:class:: Description(description: str)

   :synopsis: Free-form textual description of the domain
   :param str description: Free-form textual description, may include line
                           breaks.

--------
Emulator
--------
.. py:module:: libvirt_vmcfg.dom.elements.emulator

Element pointing to the emulator path.

.. py:class:: Emulator(emulator_path: str)

   :synopsis: Path to the emulator executable on the host
   :param str emulator_path: Path to the emulator being used. This is
                             operating system-and machine dependent.

   To find the path to your system emulator, you can use libvirt. For example:

   .. code-block:: python

      import libvirt
      from lxml import etree

      ARCH = "x86_64"
      HOST_URI = "qemu+ssh://example.org/domain"

      conn = libvirt.openReadOnly(HOST_URI)
      capab_tag = etree.XML(conn.getCapabilities())
      emulator = capab_tag.xpath(f"string(//guest/arch[@name='{ARCH}']/emulator)")

--------
Features
--------
.. py:module:: libvirt_vmcfg.dom.elements.features

Features element.

The :py:class:`Features` element is composed of a series of
:py:class:`FeatureBase` objects. These objects are composed into the final
features block.

.. py:class:: FeatureBase

   :synopsis: Abstract class of all individual features.

   .. py:attribute:: parent
      :type: Optional[Union[FeatureBase, str]]
      :value: None

      Parent tag of the given feature, ``None`` except for features in a
      nested tag.

   .. py:attribute:: name
      :type: str

      Name of the feature used in the final generated XML.

   .. py:method:: xml_tag() -> etree._Element
      :abstractmethod:

      Generate the feature XML tag.


.. py:class:: FeatureEmpty

   :synopsis: Child class of :py:class:`FeatureBase` for features tags with no
              settings or state.

   This class is abstract.


.. py:class:: FeatureBooleanState(state: Optional[bool])

   :synopsis: Child class of :py:class:`FeatureBase` for features whose only
              state is on or off. Many features fall into this category.
   :param Optional[bool] state: Whether or not the state is on or off.

   This class is abstract.


.. py:class:: Features(features: Sequence[FeatureBase])

   :synopsis: The features element for use in a
              :py:class:`~libvirt_vmcfg.dom.domain.Domain`.
   :param Sequence[FeatureBase] features: Features to add to the domain.

   This class derives from :py:class:`~libvirt_vmcfg.dom.elements.Element`.

   This element is unique. Only one features element may be present.

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Non-hypervisor specific features
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
These are features that may be passed into the :py:class:`Features` object.

.. py:module:: libvirt_vmcfg.dom.elements.features.common

.. py:class:: PAE

   :synopsis: Feature element that enables PAE for this domain.

   If you don't know what this means, you don't need it.

   .. note:: This element only applies to 32-bit x86 domains.


.. py:class:: NonPAE

   :synopsis: Feature element that disables PAE for this domain.

   If you don't know what this means, you don't need it.

   .. note:: This element only applies to 32-bit x86 domains.


.. py:class:: ACPI

   :synopsis: Enable ACPI in the domain.

   You probably want this feature for x86, x86_64, and aarch64 guests. Enable
   it on these architectures.

   .. note:: Not all architectures support this element.


.. py:class:: APIC(eoi: Optional[bool] = None)

   :synopsis: Enable the APIC in the domain.
   :param Optional[bool] eoi: Toggle availability of EOI to the domain.

   You probably want this feature for x86 and x86_64 guests. Enable it on
   these architectures.

   The ``eoi`` flag should not be toggled unless you know what you're doing.


.. py:class:: HAP(state: bool)

   :synopsis: Enable the use of hardware assisted paging.
   :param bool state: Whether or not the state is on or off.


.. py:class:: Viridian

   :synopsis: Enable Viridian (HyperV) hypervisor extensions.

   This is most useful for Windows domains.


.. py:class:: PVSpinlock(state: bool)

   :synopsis: Enable or disable paravirtualised spinlocks.
   :param bool state: Whether or not the state is on or off.

   This parameter defaults to on; you can use this feature to set it to off.


.. py:class:: PMU(state: bool)

   :synopsis: Enable or disable the performance monitoring unit.
   :param bool state: Whether or not the state is on or off.


.. py:class:: GIC(state: bool, version: Optional[int] = None)

   :synopsis: Enable or disable the general interrupt controller.
   :param bool state: Whether or not the state is on or off.
   :param Optional[int] version: An optional version for the GIC.

   The ARM equivalent of the APIC.

   Version may be either ``2``, ``3``, or ``0`` to use the same value as the
   host.

   .. note:: On aarch64, you will want to enable this.


^^^^^^^^^^^^^^^^^^^^^
KVM-specific features
^^^^^^^^^^^^^^^^^^^^^
.. py:module:: libvirt_vmcfg.dom.elements.features.kvm

This module presents KVM-specific features.


.. py:class:: IOAPICDriver

   :synopsis: IOAPIC driver selector.

   .. py:attribute:: KVM
      :value: "kvm"

      Use the KVM driver. This is the default for KVM.

   .. py:attribute:: QEMU
      :value: "qemu"

      The Qemu driver, also known as split I/O APIC mode.


.. py:class:: HPTResizing

   :synopsis: Configuration for the hash page table of a pSeries domain.

   .. py:attribute:: ENABLED
      :value: "enabled"

   .. py:attribute:: DISABLED
      :value: "disabled"

   .. py:attribute:: REQUIRED
      :value: "required"


.. py:class:: CFPCValue

   :synopsis: Configuration for the CFPC (cache flush on privilege change)
              feature for a pSeries domain.

   .. py:attribute:: BROKEN
      :value: "broken"

      CFPC is broken.

   .. py:attribute:: WORKAROUND
      :value: "workaround"

      CFPC has a software workaround.

   .. py:attribute:: FIXED
      :value: "fixed"

      CFPC has been fixed.


.. py:class:: SBBCValue

   :synopsis: Configuration for the SBBC (speculation barrier bounds checking)
              feature for a pSeries domain.

   .. py:attribute:: BROKEN
      :value: "broken"

      SBBC is broken.

   .. py:attribute:: WORKAROUND
      :value: "workaround"

      SBBC has a software workaround.

   .. py:attribute:: FIXED
      :value: "fixed"

      SBBC has been fixed.


.. py:class:: IBSValue

   :synopsis: Configuration for the IBS (indirect branch speculation) feature
              for a pSeries domain.

   .. py:attribute:: BROKEN
      :value: "broken"

      IBS is broken.

   .. py:attribute:: WORKAROUND
      :value: "workaround"

      IBS has a software workaround.

   .. py:attribute:: FIXED
      :value: "fixed"

      IBS has been fixed.


   .. py:attribute:: FIXED_CCD
      :value: "fixed-ccd"

      IBS has been fixed by disabling the cache count.


   .. py:attribute:: FIXED_NA
      :value: "fixed"

      IBS has been fixed in hardware.


   .. py:attribute:: FIXED_IBS
      :value: "fixed"

      IBS has been fixed by serialising indirect branches.


.. py:class:: SMM(state: bool, tseg: Optional[int] = None, unit: \
                  Optional[str] = "MiB")

   :synopsis: Enable or disable system management mode.
   :param bool state: Whether or not the state is on or off.
   :param Optional[int] tseg: The amount of memory allocated to the TSEG.
                              **(leave this alone unless you know
                              what you're doing)**.
   :param Optional[str] unit: Unit specifier for tseg.

   .. danger:: If your domain is booting, **leave TSEG alone!** If not, and you
               know this to be the cause, consult the libvirt documentation on
               :libvirt-domain:`hypervisor features <hypervisor-features>`.


.. py:class:: HPT(resizing: Optional[HPTResizing], maxpagesize: \
                  Optional[int] = None, unit: Optional[str] = "MiB")

   :synopsis: Enable or disable hash page tables on a pSeries domain.
   :param Optional[HPTResizing] resizing: Resizing policy to use.
   :param Optional[int] maxpagesize: Maximum page size.
   :param Optional[str] size: Size unit for maxpagesize.

   Enable hash page tables for pSeries domains.

.. py:class:: VMCoreInfo

   :synopsis: Enable the Qemu vmcoreinfo device.

   .. note:: This only works with Qemu domains.


.. py:class:: HTM(state: Optional[bool])

   :synopsis: Enable or disable hardware transactional memory support.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: NestedHV(state: Optional[bool])

   :synopsis: Enable or disable nested-hv availability for a pSeries domain.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: CCFAssist(state: Optional[bool])

   :synopsis: Enable or disable the count cache flush assist feature for a
              pSeries domain.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: CFPC(value: CFPCValue)

   :synopsis: Configure the cache flush on privilege capability for a pSeries
              domain.
   :param CFPCValue value: CFPC setting.


.. py:class:: SBBC(value: SBBCValue)

   :synopsis: Configure the speculation barrier bounds checking capability for
              a pSeries domain.
   :param SBBCValue value: SBBC setting.


.. py:class:: IBS(value: IBSValue)

   :synopsis: Configure the indirect branch speculation capability for a
              pSeries domain.
   :param IBSValue value: IBS setting.


.. py:class:: KVMFeatureSet(hidden: Optional[KVMHidden] = None, \
                            hint_dedicated: \
                            Optional[KVMHintDedicated] = None, \
                            poll_control: Optional[KVMPollControl])

   :synopsis: Settings to pass into :py:class:`KVM`.
   :param Optional[KVMHidden] hidden: Hide the KVM hypervisor from standard MSR
                                      based discovery.
   :param Optional[KVMHintDedicated] hint_dedicated: Allows a guest to enable
                                                     optimizations when running
                                                     on dedicated vCPUs.

   :param Optional[KVMPollControl] poll_control: Decrease IO completion latency
                                                 by introducing a grace period
                                                 of busy waiting.

   An instance of this object must be passed into :py:class:`KVM` to specify
   KVM-specific settings.


.. py:class:: KVMHidden(state: Optional[bool])

   :synopsis: Element for use in :py:class:`KVMFeatureSet`.
   :param Optional[bool] state: Whether or not the state is on or off.

   .. note:: It is illegal to directly pass this to a :py:class:`Feature`
             object.


.. py:class:: KVMHintDedicated(state: Optional[bool])

   :synopsis: Element for use in :py:class:`KVMFeatureSet`.
   :param Optional[bool] state: Whether or not the state is on or off.

   .. note:: It is illegal to directly pass this to a :py:class:`Feature`
             object.


.. py:class:: KVMPollControl(state: Optional[bool])

   :synopsis: Element for use in :py:class:`KVMFeatureSet`.
   :param Optional[bool] state: Whether or not the state is on or off.

   .. note:: It is illegal to directly pass this to a :py:class:`Feature`
             object.


.. py:class:: KVM(features: KVMFeatureSet)

   :synopsis: Sets features for the ``<kvm>`` block.
   :param KVMFeatureSet features: Features to enable.


.. py:class:: HyperVFeatureSet(relaxed: Optional[HyperVRelaxed] = None, \
                               vapic: Optional[HyperV_VAPIC] = None, \
                               spinlocks: Optional[HyperVSpinlocks] = None, \
                               vpindex: Optional[HyperV_VPIndex] = None, \
                               runtime: Optional[HyperVRuntime] = None, \
                               synic: Optional[HyperVSynIC] = None, \
                               stimer: Optional[HyperVStimer] = None, \
                               reset: Optional[HyperVReset] = None, \
                               vendor_id: Optional[HyperV_VendorID] = None, \
                               frequencies: \
                               Optional[HyperVFrequencies] = None, \
                               reenlightenment: \
                               Optional[HyperVReenlightenment] = None, \
                               tlbflush: Optional[HyperVTLBFlush] = None, \
                               ipi: Optional[HyperVIPI] = None, evmcs: \
                               Optional[HyperVEVMCS] = None)

   :synopsis: Feature set for :py:class:`HyperV` element.
   :param Optional[HyperVRelaxed] relaxed: Enable relaxed constraints on timers
   :param Optional[HyperV_VAPIC] vapic: Enable virtual APIC
   :param Optional[HyperVSpinlocks] spinlocks: Enable paravirtualised spinlocks
   :param Optional[HyperV_VPIndex] vpindex: Enable virtual processor index
   :param Optional[HyperVRuntime] runtime: Enable special MSR for determing \
                                           the amount of stolen time from the \
                                           guest
   :param Optional[HyperVSynIC] synic: Enable synthetic interrupt controller
   :param Optional[HyperVStimer] stimer: Enable SynIC timers, optionally with \
                                         direct mode.
   :param Optional[HyperVReset] reset: Enable hypervisor reset.
   :param Optional[HyperV_VendorID] vendor_id: Set hypervisor vendor id
   :param Optional[HyperVFrequencies] frequencies: Enable frequency MSRs
   :param Optional[HyperVReenlightenment] reenlightenment: Enable
                                                           re-enlightenment on
                                                           notification
   :param Optional[HyperVTLBFlush] tlbflush: Enable paravirtualised TLB flush
                                             support
   :param Optional[HyperVIPI] ipi: Enable paravirtualised IPI support
   :param Optional[HyperVEVMCS] evmcs: Enable Enlightened VMCS

   Enable various features improving behavior of guests running Microsoft
   Windows.

   See :libvirt-domain:`hypervisor features <hypervisor-features>` for more
   information on what these settings do.


.. py:class:: HyperVRelaxed(state: Optional[bool] = None)

   :synopsis: Enable or disable relaxed constraints on timers.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperV_VAPIC(state: Optional[bool] = None)

   :synopsis: Enable or disable virtual APIC.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVSpinlocks(state: Optional[bool] = None, \
                              retries: Optional[int] = None)

   :synopsis: Enable or disable paravirtualised spinlocks.
   :param Optional[bool] state: Whether or not the state is on or off.
   :param Optional[int] retries: Optional number of retries, must be at least
                                 4095.


.. py:class:: HyperV_VPIndex(state: Optional[bool] = None)

   :synopsis: Enable or disable virtual processor index.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVRuntime(state: Optional[bool] = None)

   :synopsis: Enable or disable MSR registers for calculating stolen guest \
              time.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVSynIC(state: Optional[bool] = None)

   :synopsis: Enable or disable the synthetic interrupt controller (SynIC).
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVStimer(state: Optional[bool] = None, direct: \
                           Optional[bool] = None))

   :synopsis: Enable or disable SynIC timers, with optional direct support.
   :param Optional[bool] state: Whether or not the state is on or off.
   :param Optional[bool] direct: Whether or not direct mode is enabled.


.. py:class:: HyperVReset(state: Optional[bool] = None)

   :synopsis: Enable or disable hypervisor reset.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperV_VendorID(state: Optional[bool] = None, value: \
                              Optional[str] = None)

   :synopsis: Enable or disable the vcpu vendor ID string, and optionally set \
              it.
   :param Optional[bool] state: Whether or not the state is on or off.
   :param Optional[str] value: Optional string, must be less than 12 \
                               characters.


.. py:class:: HyperVFrequencies(state: Optional[bool] = None)

   :synopsis: Enable or disable frequency MSRs.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVReenlightenment(state: Optional[bool] = None)

   :synopsis: Enable or disable re-enlightenment notification on migration.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVTLBFlush(state: Optional[bool] = None)

   :synopsis: Enable or disable paravirtualised TLB flush support.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVIPI(state: Optional[bool] = None)

   :synopsis: Enable or disable paravirtualised interprocessor interrupts.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperVEVMCS(state: Optional[bool] = None)

   :synopsis: Enable or disable enlightened VMCS.
   :param Optional[bool] state: Whether or not the state is on or off.


.. py:class:: HyperV(features: HyperVFeatureSet)

   :synopsis: The HyperV :py:class:`~libvirt_vmcfg.dom.elements.Element`.
   :param HyperVFeatureSet features: HyperV features to enable or disable.

------
Memory
------
.. py:module:: libvirt_vmcfg.dom.elements.memory

Memory element.

.. todo:: NUMA pinning

.. py:class:: Memory(memory: int, current_memory: Optional[int] = None)

   :synopsis: Set the amount of memory in the domain.

   :param int memory: Amount of total memory for the domain, in kilobytes.
   :param Optional[int] current_memory: Amount of memory to start the domain
                                        with. If ``None``, will default to
                                        the value in ``memory``.

   This element sets the amount of memory in the domain. ``memory`` sets the
   maximum amount of memory in the domain. ``current_memory``, if set, will
   set the amount of memory the domain will start with. This is generally only
   useful in conjunction with memory ballooning; see also the
   :py:class:`~libvirt_vmcfg.dom.elements.devices.memballoon.VirtIOMemballoon`
   element.

--------
Metadata
--------
.. py:module:: libvirt_vmcfg.dom.elements.metadata

Metadata element.

.. todo:: There has to be a better way.

.. py:class:: Metadata(metadata: lxml.etree._Element)

   :synopsis: Set the domain's metadata tags.

   :param lxml.etree._Element metadata: The root element to attach as metadata.
                                        The root should have the name
                                        "metadata" and no attributes.

   This sets arbitrary metadata on the domain. The passed-in metadata is not
   processed at all by this class.

----
Name
----
.. py:module:: libvirt_vmcfg.dom.elements.name

Element for naming the domain.

.. py:class:: Name(name: str)

   :synopsis: Set the name of the domain.

   :param str name: The name of the domain.

   This is a required element for a domain.

----------------
OS configuration
----------------
.. py:module:: libvirt_vmcfg.dom.elements.osconfig

OS configuration element.

.. todo:: More hypervisors.

.. py:class:: QemuOSConfig(arch: str, machine: str, type: \
                           VirtTypes, boot_dev_order: \
                           Optional[Sequence[str]] = None)

   :synopsis: The element specifying the ``<os>`` block of the domain
              configuration for Qemu/KVM domains.

   :param str arch: The architecture of the machine. Only ``"x86"`` or
                    ``"x86_64"`` are presently supported.
   :param str machine: The machine type this will be running on. This is
                       hypervisor specific. ``"q35"`` is a good choice for x86
                       VirtIO domains.
   :param Optional[Sequence[str]] boot_dev_order: The boot order passed to the
                                                  hypervisor.

   This element is required for all Qemu/KVM domains.

----------------
Power management
----------------
.. py:module:: libvirt_vmcfg.dom.elements.power_management

Power management element for the domain.

.. py:class:: PowerManagement(suspend_to_mem: bool = False, \
                              suspend_to_disk: bool = False)

   :synopsis: Element specifying power management parameters of the domain.

   :param bool suspend_to_mem: Enable suspending to memory for this domain.
   :param bool suspend_to_disk: Enable suspending to disk for this domain.

   This element controls advertisement of the ability to suspend to the domain.
   Note the domain can choose to circumvent this setting regardless.

   .. note:: This element is Qemu specific.

----
UUID
----
.. py:module:: libvirt_vmcfg.dom.elements.uuid

UUID element.

.. py:class:: DomainUUID(uuid: Union[UUID, str])

   :synopsis: Set the domain UUID.

   :param Union[UUID, str] uuid: The UUID to use for the domain. May be a
                                 :py:class:`python:uuid.UUID` instance, or a
                                 string.

   Specifies the domain UUID.

   .. note:: The UUID is checked for validity if a string is passed in.

===============
Device elements
===============
.. _unique: :py:attr:`libvirt_vmcfg.dom.elements.Element.unique`

These are :py:class:`Element` subclasses that are devices for the domain.

The functionality with these devices is presently limited, but it will be
expanded upon in the future.

All of these classes are available in the
:py:mod:`~libvirt_vmcfg.dom.elements.devices` module for convenience.

.. note:: As these follow the same API as the :py:class:`Element` class, the
          API will not be redocumented.

-----------
Base module
-----------
.. py:module:: libvirt_vmcfg.dom.elements.devices

This is the base module for devices. Devices (with minor exceptions) inherit
from the :py:class:`~libvirt_vmcfg.dom.elements.devices.Device` subclass, which
is itself a subclass of :py:class:`Element`.

.. py:class:: libvirt_vmcfg.dom.elements.devices.Device

   :synopsis: The root of (most) devices.

   This special class helps with cleanup of the ``<device>`` node if nothing is
   in it any longer. There are helper functions to facilitate this. Otherwise,
   it's identical to :py:class:`Element`.

   .. py:method:: get_devices_tag(root: lxml.etree._Element) -> \
                                  lxml.etree._Element

      :param lxml.etree._Element root: Root node to get or create the devices
                                       tag from.
      :return: An :py:class:`~lxml.etree._Element` containing the device node.

      Find and return the first ``<device>`` XML node encountered from the
      given root. If it is not found, it is created.

   .. py:method:: detach_xml(tags: Sequence[lxml.etree._Element]) -> None

      :param Sequence[lxml.etree._Element] tags: A sequence of tags to delete.

      This function does the cleanup of the device tag after removing the tags
      in the list, if required. All tags passed into this function must belong
      to the same root, which is derived from the first tag passed in.

-------
channel
-------
.. py:module:: libvirt_vmcfg.dom.elements.devices.channel

Elements that define communication channels between domains or between domain
and host.

.. todo:: More channel types, configuration.

.. py:class:: QemuAgentChannel

   :synopsis: Device enabling the Qemu agent channel for guest-to-host
              communication. Recommended for Qemu domains.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

-----
clock
-----
.. py:module:: libvirt_vmcfg.dom.elements.devices.clock

Clock elements and associated timers.

.. note:: Timekeeping is very complicated. You may want to review the
          :libvirt-domain:`timekeeping <time-keeping>` section of the libvirt
          manual.

.. py:class:: TickPolicy

   :synopsis: Tick policy for domains.

   .. py:attribute:: CATCHUP
      :value: "catchup"

      In the event of a delay in sending timer events to the domain, this
      policy sends ticks at a higher rate than normal to catch the domain up
      to normal time. This is transparent from the domain perspective and
      keeps the domain and host time even.

      If this tick policy is enabled, you can set the ``"catchup"`` key of
      :py:attr:`~TimerDefinition.args` to a dictionary containing parameters.
      The keys are: ``threshold``, ``skew``, and ``limit``. The values of all
      keys must be integers.

   .. py:attribute:: DELAY
      :value: "delay"

      In the event of a delay in sending timer events to the domain, this
      policy essentially continues ticking as normal from the last tick. The
      domain will not see anything amiss, but the time will be behind the host.

   .. py:attribute:: MERGE
      :value: "merge"

      This merges all skipped ticks into one tick and injects it. The domain
      time could be delayed, depending on how it reacts to this event.

   .. py:attribute:: DISCARD
      :value: "discard"

      Discards all missed ticks and continues with future ticks as normal. This
      can confuse domains that aren't prepared to handle this event, with
      unpredictable results. If the OS handles this gracefully, then the host
      and domain will match.


.. py:class:: Offset

   :synopsis: Control the domain to host time offset.

   .. py:attribute:: UTC
      :value: "utc"

      Reference against UTC.

   .. py:attribute:: LOCALTIME
      :value: "localtime"

      Clock will be referenced against the host's time.

   .. py:attribute:: TIMEZONE
      :value: "timezone"

      Clock will be referenced against the given timezone offset. Pass in
      the offset via the ``"timezone"`` key in
      :py:attr:`~TimerDefinition.args`.

   .. py:attribute:: VARIABLE
      :value: "variable"

      Clock will be referenced against an arbitrary offset applied to UTC or
      localtime.

      .. note:: See also: :py:class:`Basis`.


.. py:class:: Basis

   :synopsis: The ``basis`` attribute of :py:class:`Timer`.

   Used in :py:attr:`~Offset.VARIABLE` timers to determine the desired initial
   offset of the domain.

   This is only valid with :py:attr:`Offset.VARIABLE` clocks.

   .. py:attribute:: UTC
      :value: "utc"

      Variable clock will be referenced against UTC.

   .. py:attribute:: LOCALTIME
      :value: "localtime"

      Variable clock will be referenced against local time. Useful for Windows
      domains.


.. py:class:: RTCTrack

   :synopsis: Tracking mode for RTC timers.

   This is only usable with RTC timers.

   For more information on what each of these modes does, see the libvirt
   :libvirt-domain:`timekeeping <time-keeping>` section.

   .. py:attribute:: BOOT
      :value: "boot"

   .. py:attribute:: GUEST
      :value: "guest"

   .. py:attribute:: WALL
      :value: "wall"

   .. py:attribute:: REALTIME
      :value: "realtime"


.. py:class:: TSCMode

   :synopsis: Mode for TSC timers.

   This is only usable with TSC timers.

   For more information on what each of these modes does, see the libvirt
   :libvirt-domain:`timekeeping <time-keeping>` section.

   .. py:attribute:: AUTO
      :value: "auto"

   .. py:attribute:: NATIVE
      :value: "native"

   .. py:attribute:: EMULATE
      :value: "emulate"

   .. py:attribute:: PARAVIRT
      :value: "paravirt"

   .. py:attribute:: SMPSAFE
      :value: "smpsafe"


.. py:class:: Adjustment

   :synopsis: Non-integer clock adjustments.

   For more information on what this does, see the libvirt
   :libvirt-domain:`timekeeping <time-keeping>` section.

   .. py:attribute:: RESET
      :value: "reset"


.. py:class:: TimerRTC(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None, track: \
                       Optional[RTCTrack] = None)

   :synopsis: The RTC timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[RTCTrack] track: track parameter.

   The :wikipedia-en:`Real Time Clock <Real Time Clock>` found on virtually
   all x86 systems.

   For this timer type, you may pass in an optional argument into ``track``
   from the :py:class::`RTCTrack` enum.

   This is only usable on Qemu.


.. py:class:: TimerTSC(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None, mode: \
                       Optional[TSCMode] = None, frequency: \
                       Optional[int] = None)

   :synopsis: The TSC timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[TSCMode] mode: Optional mode to put the TSC in.
   :param Optional[int] frequency: Frequency to tick the TSC at.

   The :wikipedia-en:`Time Stamp Counter <Time Stamp Counter>` used in the x86
   and other architectures. This is the only timer that can be done in hardware
   and not emulated. Nonetheless, enabling it is not advised.

   This timer is only usable on Qemu domains.

   .. danger:: This timer can be used as part of :wikipedia-en:`Spectre \
               <Spectre (security vulnerability)>` and
               :wikipedia-en:`Meltdown <Meltdown (security \
               vulnerability)>` attacks. Unless you need it, enabling this
               timer is **not recommended**. If you need precision timing
               understand the caveats, and can accept the security risk,
               use the :py:attr:`HPET` timer instead.


.. py:class:: TimerPIT(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None)

   :synopsis: The legacy PIT timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The :wikipedia-en:`Programmable Interrupt Timer <Programmable interval \
   timer>` found on legacy x86 hardware, but still widely used. The
   :wikipedia-en:`APIC <Advanced Programmable Interrupt Controller>` has
   made it all but obsolete.

   This timer is only usable on Qemu domains.


.. py:class:: TimerHPET(*, present: bool = True, tickpolicy: \
                        Optional[TickPolicy] = None, threshold: \
                        Optional[int] = None, slew: Optional[int] = None, \
                        limit: Optional[int] = None)

   :synopsis: The HPET timer of x86 fame.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The :wikipedia-en:`High Precision Event Timer <High Precision Event \
   Timer>` is a high-performance timer found on x86 machines.

   .. danger:: This timer can be used as part of :wikipedia-en:`Spectre \
               <Spectre (security vulnerability)>` and
               :wikipedia-en:`Meltdown <Meltdown (security \
               vulnerability)>` attacks. Unless you need precision timing,
               understand the caveats, and can accept the security risk,
               enabling this timer is **not recommended**.

   .. warning:: On Intel Coffee Lake and Bay Trail hosts, the HPET is not
                usable. **Do not enable the HPET on these systems.**


.. py:class:: TimerKVMClock(*, present: bool = True, tickpolicy: \
                            Optional[TickPolicy] = None, threshold: \
                            Optional[int] = None, slew: Optional[int] = None, \
                            limit: Optional[int] = None)

   :synopsis: The KVM paravirtualised timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   This is the KVM paravirtualised timer. Usable only on Qemu domains.


.. py:class:: TimerHyperVClock(*, present: bool = True,
                       tickpolicy: Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None)

   :synopsis: The Hyper-V paravirtualised timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The Hyper-V paravirtualised clock timer. This is a good timer choice for
   Windows domains.

   This timer is only available on Qemu domains.


.. py:class:: TimerARMV(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None)

   :synopsis: The ARM V timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The ARM V architecture timer.

   This timer is only available on Qemu domains.


.. py:class:: Clock(*, offset: Optional[Offset] = None, timezone: \
                    Optional[str] = None, adjustment: \
                    Optional[Union[int, Adjustment]] = None, basis: \
                    Optional[Basis] = None, timers: Optional[Sequence[Timer]] \
                    = None)

   :synopsis: Clock element for domains.
   :param Optional[Offset] offset: The clock offset relative to the host.
   :param Optional[str] timezone: If offset is set to
                                  :py:attr:`~Offset.TIMEZONE`, this contains
                                  the timezone. Otherwise, it must be set to
                                  ``None``.
   :param Optional[Union[int, Adjustment]] adjustment: The offset adjustment.
   :param Optional[Basis] basis: The basis parameter used in
                                 :py:attr:`~offset.VARIABLE` offsets.
   :param Optional[Sequence[Timer]] timers: A sequence of timers to pass in.

   This element specifies the timekeeping for the domain.

   .. seealso:: The :libvirt-domain:`timekeeping <time-keeping>` section of the
                libvirt manual.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

-------
console
-------
.. py:module:: libvirt_vmcfg.dom.elements.devices.console

Various console elements.

.. todo:: Support more console devices, configuration.

.. py:class:: ConsolePTY

   :synopsis: Bog-standard PTY console device.

   Sets up a basic PTY, like ``virt-install`` does.

   This device takes no parameters.

   In order to have a working virtualised console, you should enable this.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

---
cpu
---
.. py:module:: libvirt_vmcfg.dom.elements.devices.cpu

CPU elements.

.. todo:: cpuset stuff, vcpu pinning.
          Hotpluggable CPU's.
          Mode should probably be an enum, not a string.

.. py:class:: CPU(vcpus: int, mode: str = "host-model")

   :synopsis: CPU configuration element.
   :param int vcpus: Number of VCPUs for the guest.
   :param str mode: CPU model for the domain.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

----
disk
----
.. py:module:: libvirt_vmcfg.dom.elements.devices.disk

Disk elements.

.. todo:: Other types of sources, including iSCSI LUNs.

.. py:class:: DeviceAttachment

   :synopsis: Available ways to make a disk appear to a domain.

   This enum tells a :py:class:`DiskTarget` what device to make the disk
   appear as to the domain.

   .. todo:: LUN attachments

   .. py:attribute:: DISK
      :value: "disk"

   .. py:attribute:: CDROM
      :value: "cdrom"

   .. py:attribute:: FLOPPY
      :value: "floppy"


.. py:class:: SourceVolumeMode

   :synopsis: Set the mode for :py:class:`DiskSourceVolume` instances.

   .. py:attribute:: HOST
      :value: "host"

   .. py:attribute:: DIRECT
      :value: "direct"


.. py:class:: TargetBus

   :synopsis: Available buses for disks to attach to.

   This enum tells a :py:class:`DiskTarget` what bus the disk will use to
   attach to the domain.

   .. py:attribute:: VIRTIO
      :value: "virtio"

   .. py:attribute:: SCSI
      :value: "scsi"

   .. py:attribute:: IDE
      :value: "ide"

   .. py:attribute:: SATA
      :value: "sata"

   .. py:attribute:: USB
      :value: "usb"

   .. py:attribute:: SD
      :value: "sd"


.. py:class:: Tray

   :synopsis: Specifies the initial tray open setting.

   This is used for :py:attr:`~DeviceAttachment.FLOPPY` or
   :py:attr:`~DeviceAttachment.CDROM` devices only.

   .. py:attribute:: OPEN
      :value: "open"

   .. py:attribute:: CLOSED
      :value: "closed"


.. py:class:: Driver

   :synopsis: Available disk drivers.

   This is passed into :py:class:`DriverOptions` to specify what type of driver
   to use for this disk.

   For KVM, you have one choice: ``QEMU``.

   .. py:attribute:: QEMU
      :value: "qemu"


.. py:class:: DriverType

   :synopsis: Available disk driver types.

   This specifies how the hypervisor should treat the source. This is passed
   into :py:class:`DriverOptions`.

   In KVM, this specifies the format.

   For block devices, you certainly want ``RAW``.

   .. py:attribute:: RAW
      :value: "raw"

   .. py:attribute:: BOCHS
      :value: "bochs"

   .. py:attribute:: QCOW2
      :value: "qcow2"

   .. py:attribute:: QED
      :value: "qed"


.. py:class:: DriverCache

   :synopsis: Available disk cache types.

   This is used in :py:class:`DriverOptions` to specify how the hypervisor/host
   will cache the disk. Not all hypervisors support all available options.
   Refer to the libvirt documentation for more information on disk caching.

   For block devices like LVM, you probably want ``NONE``. Otherwise, it's
   best to leave it alone unless you know what you're doing.

   .. py:attribute:: NONE
      :value: "none"

   .. py:attribute:: DEFAULT
      :value: "default"

   .. py:attribute:: WRITETHROUGH
      :value: "writethrough"

   .. py:attribute:: WRITEBACK
      :value: "writeback"

   .. py:attribute:: DIRECTSYNC
      :value: "directsync"

   .. py:attribute:: UNSAFE
      :value: "unsafe"


.. py:class:: DriverIO

   :synopsis: Specifies the IO type the hypervisor should use for this disk.

   This :py:class:`DriverOptions` option specifies the IO type to use for the
   domain.

   For block devices like LVM, you probably want ``NATIVE``. Otherwise, it's
   best to leave this option alone if you don't know what you're doing.

   .. note:: This option only has effect on Qemu/KVM domains.

   .. py:attribute:: NATIVE
      :value: "native"

   .. py:attribute:: THREADS
      :value: "threads"

   .. py:attribute:: IO_URING
      :value: "io_uring"


.. py:class:: DriverErrorPolicy

   :synopsis: Specifies the disk error handling policy.

   When a domain attempts I/O on the disk and gets an error, it will be
   handled by the hypervisor in one of these ways. This can be configured
   in :py:class:`DriverOptions` by setting
   :py:attr:`~DriverOptions.error_policy` (reads and writes) or
   :py:attr:`~DriverOptions.rerror_policy` (reads only).

   .. note:: :py:attr:`~DriverOptions.rerror_policy` does not allow setting
             ENOSPACE.

   .. py:attribute:: STOP
      :value: "stop"

   .. py:attribute:: REPORT
      :value: "report"

   .. py:attribute:: IGNORE
      :value: "ignore"

   .. py:attribute:: ENOSPACE
      :value: "enospace"


.. py:class:: DriverDiscard

   :synopsis: Specifies the disk TRIM/discard policy.

   This option specifies how to handle TRIM/discard requests from the domain.
   This can be changed with :py:class:`DriverOptions`.

   .. py:attribute:: UNMAP
      :value: "unmap"

   .. py:attribute:: IGNORE
      :value: "ignore"


.. py:class:: DriverDetectZeroes

   :synopsis: Specifies the zero detection policy.

   This specifies if the hypervisor should attempt to detect zero write
   requests. ``ON`` and ``OFF`` are obvious; the behaviour of ``UNMAP`` depends
   on the :py:class:`DriverDiscard` policy.

   .. note:: This can slow down domain I/O operations a great deal, but can
             potentially save space/time on very slow media.

   .. py:attribute:: OFF
      :value: "off"

   .. py:attribute:: ON
      :value: "on"

   .. py:attribute:: UNMAP
      :value: "unmap"


.. py:class:: DriverOptions(driver: Driver, type: \
                            Optional[DriverType] = None, cache: \
                            Optional[DriverCache] = None, io: \
                            Optional[DriverIO] = None, error_policy: \
                            Optional[DriverErrorPolicy] = None, rerror_policy: \
                            Optional[DriverErrorPolicy] = None, ioeventfd: \
                            Optional[bool] = None, event_idx: \
                            Optional[bool] = None, copy_on_read: \
                            Optional[bool] = None, discard: \
                            Optional[DriverDiscard] = None, detect_zeroes: \
                            Optional[DriverDetectZeroes] = None, queues: \
                            Optional[int] = None)

   :synopsis: Options for the disk driver.

   This controls the driver configuration for a disk. Usually, the defaults are
   fine except in special situations. Even then, you will likely only need to
   adjust a small subset of options.

   It is highly recommended to only use keyword arguments in the class
   constructor.

   This is a :py:func:`~python:dataclasses.dataclass`.

   .. tip:: The best source of documentation for these options is the libvirt
            documentation on :libvirt-domain:`disks
            <hard-drives-floppy-disks-cdroms>`.


.. py:class:: IOTuneOptions(total_bytes_sec: Optional[int] = None, \
                            read_bytes_sec: Optional[int] = None, \
                            write_bytes_sec: Optional[int] = None, \
                            total_bytes_sec_max: Optional[int] = None, \
                            read_bytes_sec_max: Optional[int] = None, \
                            write_bytes_sec_max: Optional[int] = None, \
                            total_iops_sec: Optional[int] = None, \
                            read_iops_sec: Optional[int] = None, \
                            write_iops_sec: Optional[int] = None, \
                            total_iops_sec_max: Optional[int] = None, \
                            read_iops_sec_max: Optional[int] = None, \
                            write_iops_sec_max: Optional[int] = None, \
                            total_bytes_sec_max_length: Optional[int] = None, \
                            read_bytes_sec_max_length: Optional[int] = None, \
                            write_bytes_sec_max_length: Optional[int] = None, \
                            total_iops_sec_max_length: Optional[int] = None, \
                            read_iops_sec_max_length: Optional[int] = None, \
                            write_iops_sec_max_length: Optional[int] = None, \
                            size_iops_sec: Optional[int] = None, \
                            group_name: Optional[str] = None

   :synopsis: Options for I/O tuning of the domain.

   This controls the I/O tuning configuration of the domain. Usually, the
   defaults are fine except in special situations. Even then, you will likely
   only ever need to adjust a small subset of options.

   It is highly recommended to only use keyword arguments in the class
   constructor.

   This is a :py:func:`~python:dataclasses.dataclass`.

   .. tip:: The best source of documentation for these options is the libvirt
            documentation on :libvirt-domain:`disks
            <hard-drives-floppy-disks-cdroms>`.


.. py:class:: DiskSource

   :synopsis: Interface for implementing disk sources.

   This class is a simple interface for implementing disk sources. A subclass
   of this must be used in your :py:class:`Disk`.

   .. py:method:: attach_xml(disk_tag: lxml.etree._Element) -> None
      :abstractmethod:

      :synopsis: Attaches the source to the given disk tag.
      :param lxml.etree._Element disk_tag: disk tag to attach to.

      .. warning:: Do your parameter validation in your ``__init__`` function!
                   Failure to do so will result in a half-setup invalid disk
                   tag in your XML if an exception is raised.


.. py:class:: DiskSourceBlockPath(path: str)

   :synopsis: Simple disk source pointing to a block device.
   :param str path: Path to the file or block device.

   This is an implementation of :py:class:`DiskSource`.


.. py:class:: DiskSourceVolume(pool: str, volume: str, mode: \
                               Optional[SourceVolumeMode] = None)

   :synopsis: Simple disk source pointing to a libvirt volume.
   :param str pool: Name of the pool the volume is in.
   :param str volume: Name of the volume.
   :param Optional[SourceVolumeMode] mode: This parameter is currently ignored.

   Set up a disk pointing to a libvirt volume at the given pool.


.. py:class:: DiskSourceDiskSourceNetHTTP(url: str)

   :synopsis: Simple disk source pointing to an HTTP(S) resource.
   :param str url: URL to source the file from.
   :raise: ValueError on invalid scheme or port

   This is an implementation of :py:class:`DiskSource`.


.. py:function:: DiskTargetCDROM(path: str, **kwargs) -> DiskTarget:

   :synopsis: Simple factory function for CDROM :py:class:`DiskTarget`
              instances.
   :param str path: Virtual device to present to the domain.


.. py:function:: DiskTargetDisk(path: str, **kwargs) -> DiskTarget:

   :synopsis: Simple factory function for disk :py:class:`DiskTarget`
              instances.
   :param str path: Virtual device to present to the domain.


.. py:function:: DiskTargetFloppy(path: str, **kwargs) -> DiskTarget:

   :synopsis: Simple factory function for floppy :py:class:`DiskTarget`
              instances.
   :param str path: Virtual device to present to the domain.


.. py:class:: Disk(source: DiskSource, target: DiskTarget, driver_opts: \
                   DriverOptions, readonly: bool = False, iotune_opts: \
                   IOTuneOptions = None)

   :synopsis: The disk element.
   :param DiskSource source: A :py:class:`DiskSource` instance.
   :param DiskTarget target: A :py:class:`DiskTarget` instance.
   :param DriverOptions driver_opts: A :py:class:`DriverOptions` instance.
   :param bool readonly: Whether or not this disk is read-only.
   :param IOTuneOptions iotune_opts: I/O tuning/throttling options.

   Given a :py:class:`DiskSource`, :py:class:`DiskTarget`, and
   :py:class:`DriverOptions`, construct a disk element.

   Example:

   .. code-block:: python

      source = DiskSourceBlockPath("/dev/zeta-vg/debian-test-01")
      target = DiskTargetDisk(next(dev), bus=TargetBus.VIRTIO)
      driver_opts = DriverOptions(driver=Driver.QEMU, type=DriverType.RAW,
                                  cache=DriverCache.NONE, io=DriverIO.NATIVE)
      disk = Disk(source, target, driver_opts, False)

   Alternatively, if we wanted, we could use an HTTP source by changing one
   line:

   .. code-block:: python

      source = DiskSourceNetHTTP("http://localhost/install.iso")

---------
interface
---------
.. py:module:: libvirt_vmcfg.dom.elements.devices.interface

Network interface elements.

.. todo:: More interface types and options.

.. py:function:: gen_mac() -> str

   :synopsis: Generate a totally random MAC address with the local only bit set
              and the group bit cleared.
   :return: A well-formed MAC address string.

   Generates a random MAC address using a secure random number generator. To
   ensure uniqueness and no conflicts with existing assignments, the local-only
   bit is set and the group bit is cleared.


.. py:class:: BridgedInterface(interface: str, mac: Optional[str] = None, \
                               model: str = "virtio")

   :synopsis: Set up an interface using a bridge.
   :param str interface: Interface to use on the host as the bridge.
   :param str mac: The MAC address of the domain. If not provided, this will be
                   generated randomly.

   Add a bridged ethernet interface using ``interface`` as the bridge.

   The MAC address is generated with :py:func:`gen_mac`.

   .. note:: This element is not `unique`_. Multiple instances of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

----------
memballoon
----------
.. py:module:: libvirt_vmcfg.dom.elements.devices.memballoon

Memory ballooning elements.

.. py:class:: VirtIOMemballoon

   Enable The VirtIO memory ballooning devices, allowing the amount of domain
   memory to be changed.

   It's a good idea to have this element for domains that support it.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

---
rng
---
.. py:module:: libvirt_vmcfg.dom.elements.devices.rng

Random Number Generator elements.

.. py:class:: RNGModel

   Model of RNG to emulate.

   .. py:attribute:: VIRTIO
      :value: "virtio"

      The VirtIO RNG device.

   .. todo:: More RNG device types.


.. py:class:: RNG(model: RNGModel = RNGModel.VIRTIO, backend_dev: \
                  str = "/dev/urandom")

   :synopsis: Emulated hardware random number generator for the domain.
   :param RNGModel model: Model of random number generator
   :param str backend_dev: Backend device for the RNG.

   An emulated RNG will greatly help domains gather more entropy on boot.
   Failure to gather enough entropy is a common reason for hangs when spawning
   a domain. Without this device, you'll need to find another way to get
   entropy into the domain.

   Note that the use of /dev/urandom is **not** a security risk. There is a
   great amount of FUD online regarding the use of /dev/urandom. Using
   /dev/random instead will cause lockups as domains and host compete for
   bits.

   You almost certainly want this element.

   This element is not `unique`_. Multiple instances of this type can exist in
   a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

------
serial
------
.. py:module:: libvirt_vmcfg.dom.elements.devices.serial

Serial device elements.

.. todo:: Possibly fold this into the
          :py:mod:`~libvirt_vmcfg.dom.elements.devices.console` module.
          More configuration.

.. py:class:: VirtIOSerialController

   A basic serial controller.

   .. note:: This element is not `unique`_. Multiple instances of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

---
usb
---
.. py:module:: libvirt_vmcfg.dom.elements.devices.usb

USB controller elements.

.. todo:: More USB controller types.
          More configurability.

.. py:class:: QemuXHCIUSBController(ports: int = 15)

   :synopsis: The Qemu XHCI USB controller. Who'd have guessed?
   :param int ports: Number of ports to enable.

   This enables the Qemu XHCI USB controller. If your guest supports this, you
   likely want to enable this. This allows you to attach virtual devices such
   as disk to the domain, virtual keyboards, and more.

   .. note:: This element is not `unique`_. Multiple instances of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.
