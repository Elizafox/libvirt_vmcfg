****************************************************
``libvirt_vmcfg.dom.elements``: Elements for domains
****************************************************
.. py:module:: libvirt_vmcfg.dom.elements

This module contains the basic framework for producing subclasses of elements.

########
Synopsis
########
Elements are subclasses of :py:class:`Element` which act as the building blocks
for the final XML sheet generated by the
:py:class:`~libvirt_vmcfg.dom.domain.Domain` class.

Each element class takes in state (if needed) that will later be used by the
:py:meth:`Element.attach_xml` method. This method performs the actual XML
generation and attachment to the tree.

Note that the elements themselves have no knowledge of the domain instance â€”
they are not coupled to the :py:class:`~libvirt_vmcfg.dom.domain.Domain`. This
prevents tight coupling.

The upshot of this is that the elements are reusable, that is, a new instance
is not required for each new :py:class:`~libvirt_vmcfg.dom.domain.Domain`, and
allows you to build your own applications on top of the elements if so desired.
All the state is kept outside the elements.

###
API
###
Below is the documentation for the actual elements API

========
Base API
========

-------
Element
-------
.. py:class:: Element

   :synopsis: The base element class. This class is partially abstract.

   .. py:attribute:: unique
      :type: bool
      :value: False

      Determines whether only one element of this **exact** type should be
      allowed. Subclasses of this element will not count as unique, only the
      exact type of the class.

      .. warning:: It is best to set this explicitly ``True`` or ``False``, and
                   not rely on inherited behaviour.

   .. py:method:: bool_to_str(val: bool) -> str
      :staticmethod:

      :param bool val: Value to convert to a string.
      :return: A string containing ``"yes"`` if ``val`` is ``True``, otherwise
               ``"no"``.

      Internal method for use by subclasses to convert a boolean value into a
      ``"yes"`` or ``"no"`` string, as used ubiquitiously by libvirt.

   .. py:method:: node_find_or_create(_root: etree._Element, _name: str, \
                                      **kwargs: Any) -> lxml.etree._Element

      :param lxml.etree._Element _root: root node to search or attach element
                                        to.
      :param str _name: name of the node to search for, or create if not found.
      :param \**kwargs: passed to :py:func:`~lxml.etree.SubElement` if the
                        node is not found.

      Internal method for finding or creating a given element. This is usually
      used for finding a node to attach other elements onto, such as the
      ``<devices>`` tag.

      The parameters are prefixed with underscores to prevent conflict with any
      keyword arguments passed on to :py:func:`~lxml.etree.SubElement`.

   .. py:method:: attach_xml(root: lxml.etree._Element) -> \
                             Sequence[lxml.etree._Element]
      :abstractmethod:

      :param lxml.etree._Element root: root node to attach elements to.
      :return: A :py:class:`~python.typing.Sequence` that is either empty or
               contains :py:class:`lxml.etree._Element` instances. These are
               the elements attached to the tree whose root is referenced by
               the ``root`` parameter.

      Attach XML node or nodes to the given root node referenced by ``root``.
      The nodes unique to this given element should be returned in this list,
      for later cleanup if :py:meth:`~libvirt_vmcfg.dom.Domain.detach_element`
      is called.

   .. py:method:: detach_xml(tags: Sequence[lxml.etree._Element]) -> None

      :param Sequence[lxml.etree._Element] tags: Tags to remove.

      Detaches the given XML nodes from the root of the tree deduced from the
      tags themselves. For simple elements, you usually do not need to override
      this method, as the behaviour does the right thing for you.

This submodule contains elements (inheriting from
:py:class:`~libvirt_vmcfg.dom.elements.Element`) that can be used to specify
all the elements a libvirt domain XML specification requires.

===================
Non-device elements
===================
The following elements are all required to be unique. See the documentation on
the :py:attr:`Element.unique` attribute for more information.

.. note:: As these follow the same API as the :py:class:`Element` class, the
          API will not be redocumented.

-----------
Description
-----------
.. py:module:: libvirt_vmcfg.dom.elements.description

Element providing description of the domain.

.. py:class:: Description(description: str)

   :synopsis: Free-form textual description of the domain
   :param str description: Free-form textual description, may include line
                           breaks.

--------
Emulator
--------
.. py:module:: libvirt_vmcfg.dom.elements.emulator

Element pointing to the emulator path.

.. todo:: Some way to get the path from the host? Document that?

.. py:class:: Emulator(emulator_path: str)

   :synopsis: Path to the emulator executable on the host
   :param str emulator_path: Path to the emulator being used. This is
                             operating system-and machine dependent.

   .. note:: ``/usr/bin/qemu-system-x86_64`` is likely a good choice for x86_64
             hosts.

--------
Features
--------
.. py:module:: libvirt_vmcfg.dom.elements.features

Features element.

.. todo:: Needs more features and configurability.

.. py:class:: FeaturesSimple(**kwargs: Optional[bool])

   :synopsis: build the ``<features>`` block for the domain.

   :param Optional[bool] \**kwargs: A list of tags to include.

   A builder for simple feature lists (like for x86).

.. py:class:: X86Features(acpi: bool = True, apic: bool = True)

   :synopsis: Wrapper around :py:class:`FeaturesSimple` for common x86
              architecture features.
   :param bool acpi: Whether or not to enable
                     :wikipedia-en:`ACPI <Advanced Configuration and Power
                     Interface>` in the domain. You probably want to enable
                     this.
   :param bool apic: Whether or not to enable the
                     :wikipedia-en:`APIC <Advanced Programmable Interrupt
                     Controller>` in the domain. You probably want to leave
                     this enabled.

   Features to enable for x86 domains. You probably want this if you're using
   an x86 or x86_64 domain.

------
Memory
------
.. py:module:: libvirt_vmcfg.dom.elements.memory

Memory element.

.. todo:: NUMA pinning

.. py:class:: Memory(memory: int, current_memory: Optional[int] = None)

   :synopsis: Set the amount of memory in the domain.

   :param int memory: Amount of total memory for the domain, in kilobytes.
   :param Optional[int] current_memory: Amount of memory to start the domain
                                        with. If ``None``, will default to
                                        the value in ``memory``.

   This element sets the amount of memory in the domain. ``memory`` sets the
   maximum amount of memory in the domain. ``current_memory``, if set, will
   set the amount of memory the domain will start with. This is generally only
   useful in conjunction with memory ballooning; see also the
   :py:class:`~libvirt_vmcfg.dom.elements.devices.memballoon.VirtIOMemballoon`
   element.

--------
Metadata
--------
.. py:module:: libvirt_vmcfg.dom.elements.metadata

Metadata element.

.. todo:: There has to be a better way.

.. py:class:: Metadata(metadata: lxml.etree._Element)

   :synopsis: Set the domain's metadata tags.

   :param lxml.etree._Element metadata: The root element to attach as metadata.
                                        The root should have the name
                                        "metadata" and no attributes.

   This sets arbitrary metadata on the domain. The passed-in metadata is not
   processed at all by this class.

----
Name
----
.. py:module:: libvirt_vmcfg.dom.elements.name

Element for naming the domain.

.. py:class:: Name(name: str)

   :synopsis: Set the name of the domain.

   :param str name: The name of the domain.

   This is a required element for a domain.

----------------
OS configuration
----------------
.. py:module:: libvirt_vmcfg.dom.elements.osconfig

OS configuration element.

.. todo:: More hypervisors.

.. py:class:: QemuOSConfig(arch: str, machine: str, type: \
                           VirtTypes, boot_dev_order: \
                           Optional[Sequence[str]] = None)

   :synopsis: The element specifying the ``<os>`` block of the domain
              configuration for Qemu/KVM domains.

   :param str arch: The architecture of the machine. Only ``"x86"`` or
                    ``"x86_64"`` are presently supported.
   :param str machine: The machine type this will be running on. This is
                       hypervisor specific. ``"q35"`` is a good choice for x86
                       VirtIO domains.
   :param Optional[Sequence[str]] boot_dev_order: The boot order passed to the
                                                  hypervisor.

   This element is required for all Qemu/KVM domains.

----------------
Power management
----------------
.. py:module:: libvirt_vmcfg.dom.elements.power_management

Power management element for the domain.

.. py:class:: PowerManagement(suspend_to_mem: bool = False, \
                              suspend_to_disk: bool = False)

   :synopsis: Element specifying power management parameters of the domain.

   :param bool suspend_to_mem: Enable suspending to memory for this domain.
   :param bool suspend_to_disk: Enable suspending to disk for this domain.

   This element controls advertisement of the ability to suspend to the domain.
   Note the domain can choose to circumvent this setting regardless.

   .. note:: This element is Qemu specific.

----
UUID
----
.. py:module:: libvirt_vmcfg.dom.elements.uuid

UUID element.

.. py:class:: DomainUUID(uuid: Union[UUID, str])

   :synopsis: Set the domain UUID.

   :param Union[UUID, str] uuid: The UUID to use for the domain. May be a
                                 :py:class:`python:uuid.UUID` instance, or a
                                 string.

   Specifies the domain UUID.

   .. note:: The UUID is checked for validity if a string is passed in.

===============
Device elements
===============
.. _unique: :py:attr:`libvirt_vmcfg.dom.elements.Element.unique`

These are :py:class:`Element` subclasses that are devices for the domain.

The functionality with these devices is presently limited, but it will be
expanded upon in the future.

All of these classes are available in the
:py:mod:`~libvirt_vmcfg.dom.elements.devices` module for convenience.

.. note:: As these follow the same API as the :py:class:`Element` class, the
          API will not be redocumented.

-----------
Base module
-----------
.. py:module:: libvirt_vmcfg.dom.elements.devices

This is the base module for devices. Devices (with minor exceptions) inherit
from the :py:class:`~libvirt_vmcfg.dom.elements.devices.Device` subclass, which
is itself a subclass of :py:class:`Element`.

.. py:class:: libvirt_vmcfg.dom.elements.devices.Device

   :synopsis: The root of (most) devices.

   This special class helps with cleanup of the ``<device>`` node if nothing is
   in it any longer. There are helper functions to facilitate this. Otherwise,
   it's identical to :py:class:`Element`.

   .. py:method:: get_devices_tag(root: lxml.etree._Element) -> \
                                  lxml.etree._Element

      :param lxml.etree._Element root: Root node to get or create the devices
                                       tag from.
      :return: An :py:class:`~lxml.etree._Element` containing the device node.

      Find and return the first ``<device>`` XML node encountered from the
      given root. If it is not found, it is created.

   .. py:method:: detach_xml(tags: Sequence[lxml.etree._Element]) -> None

      :param Sequence[lxml.etree._Element] tags: A sequence of tags to delete.

      This function does the cleanup of the device tag after removing the tags
      in the list, if required. All tags passed into this function must belong
      to the same root, which is derived from the first tag passed in.

-------
channel
-------
.. py:module:: libvirt_vmcfg.dom.elements.devices.channel

Elements that define communication channels between domains or between domain
and host.

.. todo:: More channel types, configuration.

.. py:class:: QemuAgentChannel

   :synopsis: Device enabling the Qemu agent channel for guest-to-host
              communication. Recommended for Qemu domains.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

-----
clock
-----
.. py:module:: libvirt_vmcfg.dom.elements.devices.clock

Clock elements and associated timers.

.. note:: Timekeeping is very complicated. You may want to review the
          :libvirt-domain:`timekeeping <time-keeping>` section of the libvirt
          manual.

.. py:class:: TickPolicy

   :synopsis: Tick policy for domains.

   .. py:attribute:: CATCHUP
      :value: "catchup"

      In the event of a delay in sending timer events to the domain, this
      policy sends ticks at a higher rate than normal to catch the domain up
      to normal time. This is transparent from the domain perspective and
      keeps the domain and host time even.

      If this tick policy is enabled, you can set the ``"catchup"`` key of
      :py:attr:`~TimerDefinition.args` to a dictionary containing parameters.
      The keys are: ``threshold``, ``skew``, and ``limit``. The values of all
      keys must be integers.

   .. py:attribute:: DELAY
      :value: "delay"

      In the event of a delay in sending timer events to the domain, this
      policy essentially continues ticking as normal from the last tick. The
      domain will not see anything amiss, but the time will be behind the host.

   .. py:attribute:: MERGE
      :value: "merge"

      This merges all skipped ticks into one tick and injects it. The domain
      time could be delayed, depending on how it reacts to this event.

   .. py:attribute:: DISCARD
      :value: "discard"

      Discards all missed ticks and continues with future ticks as normal. This
      can confuse domains that aren't prepared to handle this event, with
      unpredictable results. If the OS handles this gracefully, then the host
      and domain will match.


.. py:class:: Offset

   :synopsis: Control the domain to host time offset.

   .. py:attribute:: UTC
      :value: "utc"

      Reference against UTC.

   .. py:attribute:: LOCALTIME
      :value: "localtime"

      Clock will be referenced against the host's time.

   .. py:attribute:: TIMEZONE
      :value: "timezone"

      Clock will be referenced against the given timezone offset. Pass in
      the offset via the ``"timezone"`` key in
      :py:attr:`~TimerDefinition.args`.

   .. py:attribute:: VARIABLE
      :value: "variable"

      Clock will be referenced against an arbitrary offset applied to UTC or
      localtime.

      .. note:: See also: :py:class:`Basis`.


.. py:class:: Basis

   :synopsis: The ``basis`` attribute of :py:class:`Timer`.

   Used in :py:attr:`~Offset.VARIABLE` timers to determine the desired initial
   offset of the domain.

   This is only valid with :py:attr:`Offset.VARIABLE` clocks.

   .. py:attribute:: UTC
      :value: "utc"

      Variable clock will be referenced against UTC.

   .. py:attribute:: LOCALTIME
      :value: "localtime"

      Variable clock will be referenced against local time. Useful for Windows
      domains.


.. py:class:: RTCTrack

   :synopsis: Tracking mode for RTC timers.

   This is only usable with RTC timers.

   For more information on what each of these modes does, see the libvirt
   :libvirt-domain:`timekeeping <time-keeping>` section.

   .. py:attribute:: BOOT
      :value: "boot"

   .. py:attribute:: GUEST
      :value: "guest"

   .. py:attribute:: WALL
      :value: "wall"

   .. py:attribute:: REALTIME
      :value: "realtime"


.. py:class:: TSCMode

   :synopsis: Mode for TSC timers.

   This is only usable with TSC timers.

   For more information on what each of these modes does, see the libvirt
   :libvirt-domain:`timekeeping <time-keeping>` section.

   .. py:attribute:: AUTO
      :value: "auto"

   .. py:attribute:: NATIVE
      :value: "native"

   .. py:attribute:: EMULATE
      :value: "emulate"

   .. py:attribute:: PARAVIRT
      :value: "paravirt"

   .. py:attribute:: SMPSAFE
      :value: "smpsafe"


.. py:class:: Adjustment

   :synopsis: Non-integer clock adjustments.

   For more information on what this does, see the libvirt
   :libvirt-domain:`timekeeping <time-keeping>` section.

   .. py:attribute:: RESET
      :value: "reset"


.. py:class:: TimerRTC(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None, track: \
                       Optional[RTCTrack] = None)

   :synopsis: The RTC timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[RTCTrack] track: track parameter.

   The :wikipedia-en:`Real Time Clock <Real Time Clock>` found on virtually
   all x86 systems.

   For this timer type, you may pass in an optional argument into ``track``
   from the :py:class::`RTCTrack` enum.

   This is only usable on Qemu.


.. py:class:: TimerTSC(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None, mode: \
                       Optional[TSCMode] = None, frequency: \
                       Optional[int] = None)

   :synopsis: The TSC timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[TSCMode] mode: Optional mode to put the TSC in.
   :param Optional[int] frequency: Frequency to tick the TSC at.

   The :wikipedia-en:`Time Stamp Counter <Time Stamp Counter>` used in the x86
   and other architectures. This is the only timer that can be done in hardware
   and not emulated. Nonetheless, enabling it is not advised.

   This timer is only usable on Qemu domains.

   .. danger:: This timer can be used as part of :wikipedia-en:`Spectre \
               <Spectre (security vulnerability)>` and
               :wikipedia-en:`Meltdown <Meltdown (security \
               vulnerability)>` attacks. Unless you need it, enabling this
               timer is **not recommended**. If you need precision timing
               understand the caveats, and can accept the security risk,
               use the :py:attr:`HPET` timer instead.


.. py:class:: TimerPIT(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None)

   :synopsis: The legacy PIT timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The :wikipedia-en:`Programmable Interrupt Timer <Programmable interval \
   timer>` found on legacy x86 hardware, but still widely used. The
   :wikipedia-en:`APIC <Advanced Programmable Interrupt Controller>` has
   made it all but obsolete.

   This timer is only usable on Qemu domains.


.. py:class:: TimerHPET(*, present: bool = True, tickpolicy: \
                        Optional[TickPolicy] = None, threshold: \
                        Optional[int] = None, slew: Optional[int] = None, \
                        limit: Optional[int] = None)

   :synopsis: The HPET timer of x86 fame.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The :wikipedia-en:`High Precision Event Timer <High Precision Event \
   Timer>` is a high-performance timer found on x86 machines.

   .. danger:: This timer can be used as part of :wikipedia-en:`Spectre \
               <Spectre (security vulnerability)>` and
               :wikipedia-en:`Meltdown <Meltdown (security \
               vulnerability)>` attacks. Unless you need precision timing,
               understand the caveats, and can accept the security risk,
               enabling this timer is **not recommended**.

   .. warning:: On Intel Coffee Lake and Bay Trail hosts, the HPET is not
                usable. **Do not enable the HPET on these systems.**


.. py:class:: TimerKVMClock(*, present: bool = True, tickpolicy: \
                            Optional[TickPolicy] = None, threshold: \
                            Optional[int] = None, slew: Optional[int] = None, \
                            limit: Optional[int] = None)

   :synopsis: The KVM paravirtualised timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   This is the KVM paravirtualised timer. Usable only on Qemu domains.


.. py:class:: TimerHyperVClock(*, present: bool = True,
                       tickpolicy: Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None)

   :synopsis: The Hyper-V paravirtualised timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The Hyper-V paravirtualised clock timer. This is a good timer choice for
   Windows domains.

   This timer is only available on Qemu domains.


.. py:class:: TimerARMV(*, present: bool = True, tickpolicy: \
                       Optional[TickPolicy] = None, threshold: \
                       Optional[int] = None, slew: Optional[int] = None, \
                       limit: Optional[int] = None)

   :synopsis: The ARM V timer.
   :param bool present: Whether or not this timer is present.
   :param Optional[TickPolicy] tickpolicy: The :py:class:`TickPolicy` in use.
   :param Optional[int] threshold: threshold parameter used by the
                                   :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] slew: slew parameter used by the
                              :py:attr:`~TickPolicy.CATCHUP` tick policy.
   :param Optional[int] limit: limit parameter used by the
                               :py:attr:`~TickPolicy.CATCHUP` tick policy.

   The ARM V architecture timer.

   This timer is only available on Qemu domains.


.. py:class:: Clock(*, offset: Optional[Offset] = None, timezone: \
                    Optional[str] = None, adjustment: \
                    Optional[Union[int, Adjustment]] = None, basis: \
                    Optional[Basis] = None, timers: Optional[Sequence[Timer]] \
                    = None)

   :synopsis: Clock element for domains.
   :param Optional[Offset] offset: The clock offset relative to the host.
   :param Optional[str] timezone: If offset is set to
                                  :py:attr:`~Offset.TIMEZONE`, this contains
                                  the timezone. Otherwise, it must be set to
                                  ``None``.
   :param Optional[Union[int, Adjustment]] adjustment: The offset adjustment.
   :param Optional[Basis] basis: The basis parameter used in
                                 :py:attr:`~offset.VARIABLE` offsets.
   :param Optional[Sequence[Timer]] timers: A sequence of timers to pass in.

   This element specifies the timekeeping for the domain.

   .. seealso:: The :libvirt-domain:`timekeeping <time-keeping>` section of the
                libvirt manual.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

-------
console
-------
.. py:module:: libvirt_vmcfg.dom.elements.devices.console

Various console elements.

.. todo:: Support more console devices, configuration.

.. py:class:: ConsolePTY

   :synopsis: Bog-standard PTY console device.

   Sets up a basic PTY, like ``virt-install`` does.

   This device takes no parameters.

   In order to have a working virtualised console, you should enable this.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

---
cpu
---
.. py:module:: libvirt_vmcfg.dom.elements.devices.cpu

CPU elements.

.. todo:: cpuset stuff, vcpu pinning.
          Hotpluggable CPU's.
          Mode should probably be an enum, not a string.

.. py:class:: CPU(vcpus: int, mode: str = "host-model")

   :synopsis: CPU configuration element.
   :param int vcpus: Number of VCPUs for the guest.
   :param str mode: CPU model for the domain.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

----
disk
----
.. py:module:: libvirt_vmcfg.dom.elements.devices.disk

Disk elements.

.. todo:: Other types of sources, including iSCSI LUNs.

.. py:class:: DeviceAttachment

   :synopsis: Available ways to make a disk appear to a domain.

   This enum tells a :py:class:`DiskTarget` what device to make the disk
   appear as to the domain.

   .. todo:: LUN attachments

   .. py:attribute:: DISK
      :value: "disk"

   .. py:attribute:: CDROM
      :value: "cdrom"

   .. py:attribute:: FLOPPY
      :value: "floppy"


.. py:class:: TargetBus

   :synopsis: Available buses for disks to attach to.

   This enum tells a :py:class:`DiskTarget` what bus the disk will use to
   attach to the domain.

   .. py:attribute:: VIRTIO
      :value: "virtio"

   .. py:attribute:: SCSI
      :value: "scsi"

   .. py:attribute:: IDE
      :value: "ide"

   .. py:attribute:: SATA
      :value: "sata"

   .. py:attribute:: USB
      :value: "usb"

   .. py:attribute:: SD
      :value: "sd"


.. py:class:: Tray

   :synopsis: Specifies the initial tray open setting.

   This is used for :py:attr:`~DeviceAttachment.FLOPPY` or
   :py:attr:`~DeviceAttachment.CDROM` devices only.

   .. py:attribute:: OPEN
      :value: "open"

   .. py:attribute:: CLOSED
      :value: "closed"


.. py:class:: Driver

   :synopsis: Available disk drivers.

   This is passed into :py:class:`DriverOptions` to specify what type of driver
   to use for this disk.

   For KVM, you have one choice: ``QEMU``.

   .. py:attribute:: QEMU
      :value: "qemu"


.. py:class:: DriverType

   :synopsis: Available disk driver types.

   This specifies how the hypervisor should treat the source. This is passed
   into :py:class:`DriverOptions`.

   In KVM, this specifies the format.

   For block devices, you certainly want ``RAW``.

   .. py:attribute:: RAW
      :value: "raw"

   .. py:attribute:: BOCHS
      :value: "bochs"

   .. py:attribute:: QCOW2
      :value: "qcow2"

   .. py:attribute:: QED
      :value: "qed"


.. py:class:: DriverCache

   :synopsis: Available disk cache types.

   This is used in :py:class:`DriverOptions` to specify how the hypervisor/host
   will cache the disk. Not all hypervisors support all available options.
   Refer to the libvirt documentation for more information on disk caching.

   For block devices like LVM, you probably want ``NONE``. Otherwise, it's
   best to leave it alone unless you know what you're doing.

   .. py:attribute:: NONE
      :value: "none"

   .. py:attribute:: DEFAULT
      :value: "default"

   .. py:attribute:: WRITETHROUGH
      :value: "writethrough"

   .. py:attribute:: WRITEBACK
      :value: "writeback"

   .. py:attribute:: DIRECTSYNC
      :value: "directsync"

   .. py:attribute:: UNSAFE
      :value: "unsafe"


.. py:class:: DriverIO

   :synopsis: Specifies the IO type the hypervisor should use for this disk.

   This :py:class:`DriverOptions` option specifies the IO type to use for the
   domain.

   For block devices like LVM, you probably want ``NATIVE``. Otherwise, it's
   best to leave this option alone if you don't know what you're doing.

   .. note:: This option only has effect on Qemu/KVM domains.

   .. py:attribute:: NATIVE
      :value: "native"

   .. py:attribute:: THREADS
      :value: "threads"

   .. py:attribute:: IO_URING
      :value: "io_uring"


.. py:class:: DriverErrorPolicy

   :synopsis: Specifies the disk error handling policy.

   When a domain attempts I/O on the disk and gets an error, it will be
   handled by the hypervisor in one of these ways. This can be configured
   in :py:class:`DriverOptions` by setting
   :py:attr:`~DriverOptions.error_policy` (reads and writes) or
   :py:attr:`~DriverOptions.rerror_policy` (reads only).

   .. note:: :py:attr:`~DriverOptions.rerror_policy` does not allow setting
             ENOSPACE.

   .. py:attribute:: STOP
      :value: "stop"

   .. py:attribute:: REPORT
      :value: "report"

   .. py:attribute:: IGNORE
      :value: "ignore"

   .. py:attribute:: ENOSPACE
      :value: "enospace"


.. py:class:: DriverDiscard

   :synopsis: Specifies the disk TRIM/discard policy.

   This option specifies how to handle TRIM/discard requests from the domain.
   This can be changed with :py:class:`DriverOptions`.

   .. py:attribute:: UNMAP
      :value: "unmap"

   .. py:attribute:: IGNORE
      :value: "ignore"


.. py:class:: DriverDetectZeroes

   :synopsis: Specifies the zero detection policy.

   This specifies if the hypervisor should attempt to detect zero write
   requests. ``ON`` and ``OFF`` are obvious; the behaviour of ``UNMAP`` depends
   on the :py:class:`DriverDiscard` policy.

   .. note:: This can slow down domain I/O operations a great deal, but can
             potentially save space/time on very slow media.

   .. py:attribute:: OFF
      :value: "off"

   .. py:attribute:: ON
      :value: "on"

   .. py:attribute:: UNMAP
      :value: "unmap"


.. py:class:: DriverOptions(driver: Driver, type: \
                            Optional[DriverType] = None, cache: \
                            Optional[DriverCache] = None, io: \
                            Optional[DriverIO] = None, error_policy: \
                            Optional[DriverErrorPolicy] = None, rerror_policy: \
                            Optional[DriverErrorPolicy] = None, ioeventfd: \
                            Optional[bool] = None, event_idx: \
                            Optional[bool] = None, copy_on_read: \
                            Optional[bool] = None, discard: \
                            Optional[DriverDiscard] = None, detect_zeroes: \
                            Optional[DriverDetectZeroes] = None, queues: \
                            Optional[int] = None)

   :synopsis: Options for the disk driver.

   This controls the driver configuration for a disk. Usually, the defaults are
   fine except in special situations. Even then, you will likely only need to
   adjust a small subset of options.

   It is highly recommended to only use keyword arguments in the class
   constructor.

   This is a :py:func:`~python:dataclasses.dataclass`.

   .. tip:: The best source of documentation for these options is the libvirt
            documentation on :libvirt-domain:`disks
            <hard-drives-floppy-disks-cdroms>`.


.. py:class:: IOTuneOptions(total_bytes_sec: Optional[int] = None, \
                            read_bytes_sec: Optional[int] = None, \
                            write_bytes_sec: Optional[int] = None, \
                            total_bytes_sec_max: Optional[int] = None, \
                            read_bytes_sec_max: Optional[int] = None, \
                            write_bytes_sec_max: Optional[int] = None, \
                            total_iops_sec: Optional[int] = None, \
                            read_iops_sec: Optional[int] = None, \
                            write_iops_sec: Optional[int] = None, \
                            total_iops_sec_max: Optional[int] = None, \
                            read_iops_sec_max: Optional[int] = None, \
                            write_iops_sec_max: Optional[int] = None, \
                            total_bytes_sec_max_length: Optional[int] = None, \
                            read_bytes_sec_max_length: Optional[int] = None, \
                            write_bytes_sec_max_length: Optional[int] = None, \
                            total_iops_sec_max_length: Optional[int] = None, \
                            read_iops_sec_max_length: Optional[int] = None, \
                            write_iops_sec_max_length: Optional[int] = None, \
                            size_iops_sec: Optional[int] = None, \
                            group_name: Optional[str] = None

   :synopsis: Options for I/O tuning of the domain.

   This controls the I/O tuning configuration of the domain. Usually, the
   defaults are fine except in special situations. Even then, you will likely
   only ever need to adjust a small subset of options.

   It is highly recommended to only use keyword arguments in the class
   constructor.

   This is a :py:func:`~python:dataclasses.dataclass`.

   .. tip:: The best source of documentation for these options is the libvirt
            documentation on :libvirt-domain:`disks
            <hard-drives-floppy-disks-cdroms>`.


.. py:class:: DiskSource

   :synopsis: Interface for implementing disk sources.

   This class is a simple interface for implementing disk sources. A subclass
   of this must be used in your :py:class:`Disk`.

   .. py:method:: attach_xml(disk_tag: lxml.etree._Element) -> None
      :abstractmethod:

      :synopsis: Attaches the source to the given disk tag.
      :param lxml.etree._Element disk_tag: disk tag to attach to.

      .. warning:: Do your parameter validation in your ``__init__`` function!
                   Failure to do so will result in a half-setup invalid disk
                   tag in your XML if an exception is raised.


.. py:class:: DiskSourceBlockPath(path: str)

   :synopsis: Simple disk source pointing to a block device.
   :param str path: Path to the file or block device.

   This is an implementation of :py:class:`DiskSource`.


.. py:class:: DiskSourceDiskSourceNetHTTP(url: str)

   :synopsis: Simple disk source pointing to an HTTP(S) resource.
   :param str url: URL to source the file from.
   :raise: ValueError on invalid scheme or port

   This is an implementation of :py:class:`DiskSource`.


.. py:function:: DiskTargetCDROM(path: str, **kwargs) -> DiskTarget:

   :synopsis: Simple factory function for CDROM :py:class:`DiskTarget`
              instances.
   :param str path: Virtual device to present to the domain.


.. py:function:: DiskTargetDisk(path: str, **kwargs) -> DiskTarget:

   :synopsis: Simple factory function for disk :py:class:`DiskTarget`
              instances.
   :param str path: Virtual device to present to the domain.


.. py:function:: DiskTargetFloppy(path: str, **kwargs) -> DiskTarget:

   :synopsis: Simple factory function for floppy :py:class:`DiskTarget`
              instances.
   :param str path: Virtual device to present to the domain.


.. py:class:: Disk(source: DiskSource, target: DiskTarget, driver_opts: \
                   DriverOptions, readonly: bool = False, iotune_opts: \
                   IOTuneOptions = None)

   :synopsis: The disk element.
   :param DiskSource source: A :py:class:`DiskSource` instance.
   :param DiskTarget target: A :py:class:`DiskTarget` instance.
   :param DriverOptions driver_opts: A :py:class:`DriverOptions` instance.
   :param bool readonly: Whether or not this disk is read-only.
   :param IOTuneOptions iotune_opts: I/O tuning/throttling options.

   Given a :py:class:`DiskSource`, :py:class:`DiskTarget`, and
   :py:class:`DriverOptions`, construct a disk element.

   Example:

   .. code-block:: python

      source = DiskSourceBlockPath("/dev/zeta-vg/debian-test-01")
      target = DiskTargetDisk(next(dev), bus=TargetBus.VIRTIO)
      driver_opts = DriverOptions(driver=Driver.QEMU, type=DriverType.RAW,
                                  cache=DriverCache.NONE, io=DriverIO.NATIVE)
      disk = Disk(source, target, driver_opts, False)

   Alternatively, if we wanted, we could use an HTTP source by changing one
   line:

   .. code-block:: python

      source = DiskSourceNetHTTP("http://localhost/install.iso")

---------
interface
---------
.. py:module:: libvirt_vmcfg.dom.elements.devices.interface

Network interface elements.

.. todo:: More interface types and options.

.. py:function:: gen_mac() -> str

   :synopsis: Generate a totally random MAC address with the local only bit set
              and the group bit cleared.
   :return: A well-formed MAC address string.

   Generates a random MAC address using a secure random number generator. To
   ensure uniqueness and no conflicts with existing assignments, the local-only
   bit is set and the group bit is cleared.


.. py:class:: BridgedInterface(interface: str, mac: Optional[str] = None, \
                               model: str = "virtio")

   :synopsis: Set up an interface using a bridge.
   :param str interface: Interface to use on the host as the bridge.
   :param str mac: The MAC address of the domain. If not provided, this will be
                   generated randomly.

   Add a bridged ethernet interface using ``interface`` as the bridge.

   The MAC address is generated with :py:func:`gen_mac`.

   .. note:: This element is not `unique`_. Multiple instances of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

----------
memballoon
----------
.. py:module:: libvirt_vmcfg.dom.elements.devices.memballoon

Memory ballooning elements.

.. py:class:: VirtIOMemballoon

   Enable The VirtIO memory ballooning devices, allowing the amount of domain
   memory to be changed.

   It's a good idea to have this element for domains that support it.

   .. note:: This element is `unique`_. Only one instance of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

---
rng
---
.. py:module:: libvirt_vmcfg.dom.elements.devices.rng

Random Number Generator elements.

.. py:class:: RNGModel

   Model of RNG to emulate.

   .. py:attribute:: VIRTIO
      :value: "virtio"

      The VirtIO RNG device.

   .. todo:: More RNG device types.


.. py:class:: RNG(model: RNGModel = RNGModel.VIRTIO, backend_dev: \
                  str = "/dev/urandom")

   :synopsis: Emulated hardware random number generator for the domain.
   :param RNGModel model: Model of random number generator
   :param str backend_dev: Backend device for the RNG.

   An emulated RNG will greatly help domains gather more entropy on boot.
   Failure to gather enough entropy is a common reason for hangs when spawning
   a domain. Without this device, you'll need to find another way to get
   entropy into the domain.

   Note that the use of /dev/urandom is **not** a security risk. There is a
   great amount of FUD online regarding the use of /dev/urandom. Using
   /dev/random instead will cause lockups as domains and host compete for
   bits.

   You almost certainly want this element.

   This element is not `unique`_. Multiple instances of this type can exist in
   a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

------
serial
------
.. py:module:: libvirt_vmcfg.dom.elements.devices.serial

Serial device elements.

.. todo:: Possibly fold this into the
          :py:mod:`~libvirt_vmcfg.dom.elements.devices.console` module.
          More configuration.

.. py:class:: VirtIOSerialController

   A basic serial controller.

   .. note:: This element is not `unique`_. Multiple instances of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.

---
usb
---
.. py:module:: libvirt_vmcfg.dom.elements.devices.usb

USB controller elements.

.. todo:: More USB controller types.
          More configurability.

.. py:class:: QemuXHCIUSBController(ports: int = 15)

   :synopsis: The Qemu XHCI USB controller. Who'd have guessed?
   :param int ports: Number of ports to enable.

   This enables the Qemu XHCI USB controller. If your guest supports this, you
   likely want to enable this. This allows you to attach virtual devices such
   as disk to the domain, virtual keyboards, and more.

   .. note:: This element is not `unique`_. Multiple instances of this type can
             exist in a given :py:class:`~libvirt_vmcfg.dom.domain.Domain`.
